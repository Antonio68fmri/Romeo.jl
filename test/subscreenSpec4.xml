<?xml version="1.0" encoding="UTF-8"?>
<scene xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:noNamespaceSchemaLocation="subscreenSchema.xsd">

<!-- Test purposes
     1) explore GLVisualize examples, here nbody.jl           
     2) include signal timed displays (with all the machinery 
     3) Use multiple <inline> tags (in different modules), including 
        cross referencing (see the doAxis function nelow)
     4) Test mixing of signal based and static (non signal based) display
-->
<!-- Function definitions  -->

<julia  modulename="SubScreensInline2">
   <inline>
   <?julia      
      module SubScreensInline2

      using GLAbstraction, GLWindow, ModernGL, GLVisualize,  AbstractGPUArray
      using ColorTypes, GeometryTypes
      using Meshes, MeshIO
      using Romeo, TBCompletedM

      export doMesh, doAxis, doMeshAxis
      
      warn ("GLAbstraction.Camera is not exported")
      Camera = GLAbstraction.Camera

      ## Example from GLVisualize/test/test_mesh
      function create_example_mesh()
          # volume of interest
          x_min, x_max = -1, 15
          y_min, y_max = -1, 5
          z_min, z_max = -1, 5
          scale = 8
       
          b1(x,y,z) = box(   x,y,z, 0,0,0,3,3,3)
          s1(x,y,z) = sphere(x,y,z, 3,3,3,sqrt(3))
          f1(x,y,z) = min(b1(x,y,z), s1(x,y,z))  # UNION
          b2(x,y,z) = box(   x,y,z, 5,0,0,8,3,3)
          s2(x,y,z) = sphere(x,y,z, 8,3,3,sqrt(3))
          f2(x,y,z) = max(b2(x,y,z), -s2(x,y,z)) # NOT
          b3(x,y,z) = box(   x,y,z, 10,0,0,13,3,3)
          s3(x,y,z) = sphere(x,y,z, 13,3,3,sqrt(3))
          f3(x,y,z) = max(b3(x,y,z), s3(x,y,z))  # INTERSECTION
          f(x,y,z) = min(f1(x,y,z), f2(x,y,z), f3(x,y,z))
       
          vol = volume(f, x_min,y_min,z_min,x_max,y_max,z_max, scale)
          msh = GLNormalMesh(vol, 0.0f0)
          return msh
      end

      function create_example_axis()
        dirlen 	= 1f0
        baselen = 0.02f0
        axis 	= [
      	 (Cube(Vec3(baselen), Vec3(dirlen, baselen, baselen)), RGBA(1f0,0f0,0f0,1f0)), 
      	 (Cube(Vec3(baselen), Vec3(baselen, dirlen, baselen)), RGBA(0f0,1f0,0f0,1f0)), 
      	 (Cube(Vec3(baselen), Vec3(baselen, baselen, dirlen)), RGBA(0f0,0f0,1f0,1f0))
          ]
        axis = map(GLNormalMesh, axis)
        axis = merge(axis)
      end

      function doMesh(sc::Screen,cam::Camera)
          println("Entered doMesh")
	  msh  = create_example_mesh()
          msh
      end

     function doAxis (sc::Screen,cam::Camera)
          println("Entered doAxis")
          ax   = create_example_axis()
          ax
     end

     function doMeshAxis (sc::Screen,cam::Camera)
          println("Entered doMeshAxis")
	  msh  = create_example_mesh()
          ax   = create_example_axis()
          (msh,ax)
     end

      end    # SubScreensInline2
   ?>
   </inline>
</julia>


<julia  modulename="SubScreensInline">
   <signal name="timer"  
           init="timerInitFun" 
           advance="timerAdvanceFun"
           type="Reactive.Input{Int64}"/>
   <!-- now  read the inlined Julia code -->
   <inline>
   <?julia      
module SubScreensInline

using GLAbstraction, GLWindow, ModernGL, GLVisualize,  AbstractGPUArray
using ColorTypes, GeometryTypes
using Meshes, MeshIO
using Reactive
using Romeo, TBCompletedM
using ODE

using xmlNS.SubScreensInline2


export doPlanets,  timerInitFun, timerAdvanceFun
      
warn ("GLAbstraction.Camera is not exported")
Camera = GLAbstraction.Camera

      ## Example from GLVisualize/test/nbody.jl
function F(t,y)
    
    #Number of Planets (note we're solving the n-body problem, rather than just a 3-body problem)
    n = int(length(y)/6)
    
    #Extract current position and velocity
    r = zeros(n,3)
    v = zeros(n,3)
    for i=1:n
        r[i,:] = y[(i-1)*6+1:(i-1)*6+3]
        v[i,:] = y[(i-1)*6+4:(i-1)*6+6]
    end
        
    #Calculate spatial derivatives
    drdt = v
        
    #Work out velocity derivatives (ie accelerations)
    dvdt = zeros(n,3)
    for i = 1:n
        for j = 1:n
            if i != j
                dvdt[i,:] += -G*m[j]*(r[i,:]-r[j,:])/(norm(r[i,:]-r[j,:])^3)
            end
        end
    end
    
    #Combine back together into dydt vector
    dydt = zeros(6*n)
    for i = 1:n
        dydt[6(i-1)+1] = drdt[i,1]
        dydt[6(i-1)+2] = drdt[i,2]
        dydt[6(i-1)+3] = drdt[i,3]
        dydt[6(i-1)+4] = dvdt[i,1]
        dydt[6(i-1)+5] = dvdt[i,2]
        dydt[6(i-1)+6] = dvdt[i,3]
    end
    return dydt
end  # Function F(t,y)

function worldCreate()

   #Set the masses
   global m 
   m = [5,4,3,5]
   n = length(m)

   #Set the gravitational field strength
   global G
   G = .2

   #Set initial positions and velocities 
   r0 = zeros(n,3)
   r0[1,:] = [1.0,-1.0,1.0]
   r0[2,:] = [1,3,0.0]
   r0[3,:] = [-1,-2,0.0]
   r0[4,:] = [0,0,0.0]

   #Select a reasonable set of speeds (avoid cases where
   #       a singularity happens stopping the ode solver
   v0 = rand(n,3)


    
   # Aggregate initial data (position, speed)  in a format that
   # the ODE solver and function F handle
   y0 = zeros(6*n)
   for i = 1:n
     y0[6(i-1)+1] = r0[i,1]
     y0[6(i-1)+2] = r0[i,2]
     y0[6(i-1)+3] = r0[i,3]
     y0[6(i-1)+4] = v0[i,1]
     y0[6(i-1)+5] = v0[i,2]
     y0[6(i-1)+6] = v0[i,3]
   end
    return (m,y0,G)
end

function worldOperate(y0)
   #Solve the system
   tf = 10
   stepsPerUnitTime = 200
   tspan = linspace(0,tf,tf*stepsPerUnitTime)
   t,y = ode23s(F, y0, tspan; points=:specified);
   return t,y
end

function send_frame(i, planets)
    p = planets[i, 1:4]
    reshape(p, (2,2))
end

function reformatData(m, t, y)
    #Extract the data into a useful form 
    n = length(m)
    ymat= hcat(y...)

    # gather some results, do we need to construct such an array
    # positions
    rcoords = sort([  [6(i-1)+1 for i = 1:n],
                      [6(i-1)+2 for i = 1:n],
                      [6(i-1)+3 for i = 1:n]])
    rcoords = convert(Array{Int64,1}, rcoords)
    const r = map(Float32, ymat[rcoords,:])
    
    const planets = hcat( [ reinterpret(Point3{Float32},
                                        r[3(i-1)+1:3(i-1)+3,:],
                                        (size(r, 2),)) for i=1:n]...)
    println("size(planets[:, 1]=", size(planets[:, 1]))                                            
    return planets
end



function doPlanets( sc::Screen,cam::Camera, time_i) # beware 3rd result   
    m,y0,G = worldCreate()
    t,y    = worldOperate(y0)  
    planets = reformatData(m, t, y)
    len= size(planets, 1)

    # this is used for communication with timerAdvanceFun
    global lenPlanet
    lenPlanet = len    

    const positions     = lift(send_frame, time_i, Input(planets))
    const robj          = visualize(positions, model=scalematrix(Vec3(0.1f0)), 
                                    screen=sc, camera=cam)


    const robjPl  = [ visualize(
    				reshape(planets[:, i], (round(Int,len/20), 20)),
				particle_color=RGBA(rand(Float32,3)..., 0.4f0),
    				model=scalematrix(Vec3(0.01f0)),
                                screen=sc, camera=cam)
                       for i=1:4]

    # for now I have an issue with the second (robjPl)
    for ro in robjPl
        println("typeof(ro):", typeof(ro))
    end
    robjPlTy = Array{RenderObject,1}(robjPl)   #::Array{RenderObject,1}


    return (robj, robjPlTy, doAxis(sc,cam)) 
    #return robj
end


#  provide the timing signal:
function timerInitFun()
   println("In timerInitFun")
   return Input(1) 
end

# How do we get lenPlanet in there?
function timerAdvanceFun(timer::Reactive.Input{Int64})
    global lenPlanet
    push!(timer, mod1(timer.value+1, lenPlanet))
end


end    # SubScreensInline

#==
For checking:

push!(GLVisualize.ROOT_SCREEN.renderlist, robj)
append!(GLVisualize.ROOT_SCREEN.renderlist, planet_lines)

==#
   ?>
   </inline>
</julia>
<!-- Subscreen description -->
 <subscreen rows="2" cols="2" name="MAIN">
  <rowsizes>1,4</rowsizes>
  <colsizes>4,1</colsizes>
  <table>
    <tr>
     <subscreen name="A1"/>
     <subscreen name="A2"/>
     </tr>
    <tr>
     <subscreen name="B1"/>
     <subscreen name="INNER"/>
     </tr>
   </table>
 </subscreen>

 <subscreen rows="4" cols="1" name="INNER">
  <rowsizes>1,1,1,1</rowsizes>
  <colsizes>1</colsizes>
  <table>
    <tr>
     <subscreen name="IA1"/>
    </tr>
    <tr>
     <subscreen name="IB1"/>
    </tr>
    <tr>
     <subscreen name="IC1"/>
    </tr>
    <tr>
     <subscreen name="ID1"/>
    </tr>
   </table>
 </subscreen>

<!-- Subscreen contents -->

 <setplot  ref="B1"  fn="doPlanets">
       <addparm name="timer" />
 </setplot>

 <setplot  ref="IA1"  fn="doMeshAxis"/>
 <setplot  ref="IB1"  fn="doMeshAxis"> 
      <rotateModel>Pi/2, 0.0, 0.0</rotateModel>
 </setplot>
 <setplot  ref="IC1"  fn="doMeshAxis">
      <rotateModel>0.0, Pi/2, 0.0</rotateModel>
 </setplot>
 <setplot  ref="ID1"  fn="doMeshAxis">
      <rotateModel>0.0, 0.0, Pi/2</rotateModel>
 </setplot>
 <setplot  ref="A2"  fn="doAxis"/>

 <!-- Connectors -->

 <!-- Debug options -->

<debug>
    <dump ref="B1"/>
</debug>

</scene>
<!-- This ends the scene-->
