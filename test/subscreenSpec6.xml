<?xml version="1.0" encoding="UTF-8"?>
<scene xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:noNamespaceSchemaLocation="subscreenSchema.xsd">

<!-- Test purposes
      Try the Lorentz attractor
-->
<!-- Function definitions  -->


<julia  modulename="SubScreensInline">
   <signal name="timer"  
           init="timerInitFun" 
           advance="timerAdvanceFun"
           type="Reactive.Input{Int64}"/>
   <!-- now  read the inlined Julia code -->
   <inline>
   <?julia      
module SubScreensInline

using GLAbstraction, GLWindow, ModernGL, GLVisualize,  AbstractGPUArray
using ColorTypes, GeometryTypes
using Meshes, MeshIO
using Reactive
using Romeo, TBCompletedM
using ODE

export doPlanets,  timerInitFun, timerAdvanceFun
      
warn ("GLAbstraction.Camera is not exported")
Camera = GLAbstraction.Camera

      ## Example from GLVisualize/test/nbody.jl
function F(t,y)
    
end  # Function F(t,y)

function worldCreate()
end

function worldOperate(y0)
   #Solve the system
   tf = 10
   stepsPerUnitTime = 200
   tspan = linspace(0,tf,tf*stepsPerUnitTime)
   t,y = ode23s(F, y0, tspan; points=:specified);
   return t,y
end

function send_frame(i, planets)
    p = planets[i, 1:4]
    reshape(p, (2,2))
end

function reformatData(m, t, y)
    #Extract the data into a useful form 
    n = length(m)
    ymat= hcat(y...)

    # gather some results, do we need to construct such an array
    # positions
    rcoords = sort([  [6(i-1)+1 for i = 1:n],
                      [6(i-1)+2 for i = 1:n],
                      [6(i-1)+3 for i = 1:n]])
    rcoords = convert(Array{Int64,1}, rcoords)
    const r = map(Float32, ymat[rcoords,:])
    
    const planets = hcat( [ reinterpret(Point3{Float32},
                                        r[3(i-1)+1:3(i-1)+3,:],
                                        (size(r, 2),)) for i=1:n]...)
    println("size(planets[:, 1]=", size(planets[:, 1]))                                            
    return planets
end



function doPlanets( sc::Screen,cam::Camera, time_i) # beware 3rd result   
    m,y0,G = worldCreate()
    t,y    = worldOperate(y0)  
    planets = reformatData(m, t, y)
    len= size(planets, 1)

    # this is used for communication with timerAdvanceFun
    global lenPlanet
    lenPlanet = len    

    const positions     = lift(send_frame, time_i, Input(planets))
    const robj          = visualize(positions, model=scalematrix(Vec3(0.1f0)))


    const robjPl  = [ visualize(
    				reshape(planets[:, i], (round(Int,len/20), 20)),
				particle_color=RGBA(rand(Float32,3)..., 0.4f0),
    				model=scalematrix(Vec3(0.01f0)))
                       for i=1:4]

    # for now I have an issue with the second (robjPl)
    #return (robj, robjPl, len) 

    return robj
end


#  provide the timing signal:
function timerInitFun()
   println("In timerInitFun")
   return Input(1) 
end

# How do we get lenPlanet in there?
function timerAdvanceFun(timer::Reactive.Input{Int64})
    global lenPlanet
    push!(timer, mod1(timer.value+1, lenPlanet))
end


end    # SubScreensInline

   ?>
   </inline>
</julia>
<!-- Subscreen description -->
 <subscreen rows="2" cols="2" name="MAIN">
  <rowsizes>1,4</rowsizes>
  <colsizes>4,1</colsizes>
  <table>
    <tr>
     <subscreen name="A1"/>
     <subscreen name="A2"/>
     </tr>
    <tr>
     <subscreen name="B1"/>
     <subscreen name="INNER"/>
     </tr>
   </table>
 </subscreen>

 <subscreen rows="4" cols="1" name="INNER">
  <rowsizes>1,1,1,1</rowsizes>
  <colsizes>1</colsizes>
  <table>
    <tr>
     <subscreen name="IA1"/>
    </tr>
    <tr>
     <subscreen name="IB1"/>
    </tr>
    <tr>
     <subscreen name="IC1"/>
    </tr>
    <tr>
     <subscreen name="ID1"/>
    </tr>
   </table>
 </subscreen>

<!-- Subscreen contents -->

 <setplot  ref="B1"  fn="doPlanets">
       <addparm name="timer" />
 </setplot>

 <!-- Connectors -->

 <!-- Debug options -->

<debug>
    <dump ref="B1"/>
</debug>

</scene>
<!-- This ends the scene-->
